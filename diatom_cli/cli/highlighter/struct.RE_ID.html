<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `RE_ID` struct in crate `diatom_cli`."><meta name="keywords" content="rust, rustlang, rust-lang, RE_ID"><title>RE_ID in diatom_cli::cli::highlighter - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../../../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../../../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../diatom_cli/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../diatom_cli/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">RE_ID</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block"><li><a href="#structfield.__private_field">__private_field</a></li></ul><h3><a href="#deref-methods-Regex">Methods from Deref&lt;Target=Regex&gt;</a></h3><ul class="block"><li><a href="#method.as_str">as_str</a></li><li><a href="#method.capture_locations">capture_locations</a></li><li><a href="#method.capture_names">capture_names</a></li><li><a href="#method.captures">captures</a></li><li><a href="#method.captures_iter">captures_iter</a></li><li><a href="#method.captures_len">captures_len</a></li><li><a href="#method.captures_read">captures_read</a></li><li><a href="#method.captures_read_at">captures_read_at</a></li><li><a href="#method.find">find</a></li><li><a href="#method.find_at">find_at</a></li><li><a href="#method.find_iter">find_iter</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.is_match_at">is_match_at</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replace_all">replace_all</a></li><li><a href="#method.replacen">replacen</a></li><li><a href="#method.shortest_match">shortest_match</a></li><li><a href="#method.shortest_match_at">shortest_match_at</a></li><li><a href="#method.split">split</a></li><li><a href="#method.splitn">splitn</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Deref-for-RE_ID">Deref</a></li><li><a href="#impl-LazyStatic-for-RE_ID">LazyStatic</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-RE_ID">RefUnwindSafe</a></li><li><a href="#impl-Send-for-RE_ID">Send</a></li><li><a href="#impl-Sync-for-RE_ID">Sync</a></li><li><a href="#impl-Unpin-for-RE_ID">Unpin</a></li><li><a href="#impl-UnwindSafe-for-RE_ID">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-RE_ID">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-RE_ID">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-RE_ID">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-RE_ID">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-RE_ID">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-RE_ID">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-RE_ID">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In diatom_cli::cli::highlighter</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Struct <a href="../../index.html">diatom_cli</a>::<wbr><a href="../index.html">cli</a>::<wbr><a href="index.html">highlighter</a>::<wbr><a class="struct" href="#">RE_ID</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/diatom_cli/cli/highlighter.rs.html#30-48">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust struct"><code>struct RE_ID {
    __private_field: <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.unit.html">()</a>,
}</code></pre></div><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.__private_field" class="structfield small-section-header"><a href="#structfield.__private_field" class="anchor field">§</a><code>__private_field: <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.unit.html">()</a></code></span><h2 id="deref-methods-Regex" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = Regex&gt;</span><a href="#deref-methods-Regex" class="anchor">§</a></h2><div id="deref-methods-Regex-1"><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_match" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.is_match" class="fn">is_match</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if there is a match for the regex in the
string given.</p>
<p>It is recommended to use this method if all you need to do is test
a match, since the underlying matching engine may be able to do less
work.</p>
<h5 id="example"><a href="#example">Example</a></h5>
<p>Test if some text contains at least one word with exactly 13
Unicode word characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;I categorically deny having triskaidekaphobia.&quot;</span>;
<span class="macro">assert!</span>(Regex::new(<span class="string">r&quot;\b\w{13}\b&quot;</span>).unwrap().is_match(text));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;'t&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end byte range of the leftmost-first match in
<code>text</code>. If no match exists, then <code>None</code> is returned.</p>
<p>Note that this should only be used if you want to discover the position
of the match. Testing the existence of a match is faster if you use
<code>is_match</code>.</p>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<p>Find the start and end location of the first word with exactly 13
Unicode word characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;I categorically deny having triskaidekaphobia.&quot;</span>;
<span class="kw">let </span>mat = Regex::new(<span class="string">r&quot;\b\w{13}\b&quot;</span>).unwrap().find(text).unwrap();
<span class="macro">assert_eq!</span>(mat.start(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(mat.end(), <span class="number">15</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find_iter" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.find_iter" class="fn">find_iter</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>) -&gt; Matches&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator for each successive non-overlapping match in
<code>text</code>, returning the start and end byte indices with respect to
<code>text</code>.</p>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<p>Find the start and end location of every word with exactly 13 Unicode
word characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;Retroactively relinquishing remunerations is reprehensible.&quot;</span>;
<span class="kw">for </span>mat <span class="kw">in </span>Regex::new(<span class="string">r&quot;\b\w{13}\b&quot;</span>).unwrap().find_iter(text) {
    <span class="macro">println!</span>(<span class="string">&quot;{:?}&quot;</span>, mat);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.captures" class="fn">captures</a>&lt;'t&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Captures&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the capture groups corresponding to the leftmost-first
match in <code>text</code>. Capture group <code>0</code> always corresponds to the entire
match. If no match is found, then <code>None</code> is returned.</p>
<p>You should only use <code>captures</code> if you need access to the location of
capturing group matches. Otherwise, <code>find</code> is faster for discovering
the location of the overall match.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p>Say you have some text with movie names and their release years,
like “‘Citizen Kane’ (1941)”. It’d be nice if we could search for text
looking like that, while also extracting the movie name and its release
year separately.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;&#39;([^&#39;]+)&#39;\s+\((\d{4})\)&quot;</span>).unwrap();
<span class="kw">let </span>text = <span class="string">&quot;Not my favorite movie: &#39;Citizen Kane&#39; (1941).&quot;</span>;
<span class="kw">let </span>caps = re.captures(text).unwrap();
<span class="macro">assert_eq!</span>(caps.get(<span class="number">1</span>).unwrap().as_str(), <span class="string">&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(caps.get(<span class="number">2</span>).unwrap().as_str(), <span class="string">&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(caps.get(<span class="number">0</span>).unwrap().as_str(), <span class="string">&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);
<span class="comment">// You can also access the groups by index using the Index notation.
// Note that this will panic on an invalid index.
</span><span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">1</span>], <span class="string">&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">2</span>], <span class="string">&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">0</span>], <span class="string">&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);</code></pre></div>
<p>Note that the full match is at capture group <code>0</code>. Each subsequent
capture group is indexed by the order of its opening <code>(</code>.</p>
<p>We can make this example a bit clearer by using <em>named</em> capture groups:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;&#39;(?P&lt;title&gt;[^&#39;]+)&#39;\s+\((?P&lt;year&gt;\d{4})\)&quot;</span>)
               .unwrap();
<span class="kw">let </span>text = <span class="string">&quot;Not my favorite movie: &#39;Citizen Kane&#39; (1941).&quot;</span>;
<span class="kw">let </span>caps = re.captures(text).unwrap();
<span class="macro">assert_eq!</span>(caps.name(<span class="string">&quot;title&quot;</span>).unwrap().as_str(), <span class="string">&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(caps.name(<span class="string">&quot;year&quot;</span>).unwrap().as_str(), <span class="string">&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(caps.get(<span class="number">0</span>).unwrap().as_str(), <span class="string">&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);
<span class="comment">// You can also access the groups by name using the Index notation.
// Note that this will panic on an invalid group name.
</span><span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="string">&quot;title&quot;</span>], <span class="string">&quot;Citizen Kane&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="string">&quot;year&quot;</span>], <span class="string">&quot;1941&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">0</span>], <span class="string">&quot;&#39;Citizen Kane&#39; (1941)&quot;</span>);
</code></pre></div>
<p>Here we name the capture groups, which we can access with the <code>name</code>
method or the <code>Index</code> notation with a <code>&amp;str</code>. Note that the named
capture groups are still accessible with <code>get</code> or the <code>Index</code> notation
with a <code>usize</code>.</p>
<p>The <code>0</code>th capture group is always unnamed, so it must always be
accessed with <code>get(0)</code> or <code>[0]</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_iter" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.captures_iter" class="fn">captures_iter</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>) -&gt; CaptureMatches&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over all the non-overlapping capture groups matched
in <code>text</code>. This is operationally the same as <code>find_iter</code>, except it
yields information about capturing group matches.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<p>We can use this to find all movie titles and their release years in
some text, where the movie is formatted like “‘Title’ (xxxx)”:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;&#39;(?P&lt;title&gt;[^&#39;]+)&#39;\s+\((?P&lt;year&gt;\d{4})\)&quot;</span>)
               .unwrap();
<span class="kw">let </span>text = <span class="string">&quot;&#39;Citizen Kane&#39; (1941), &#39;The Wizard of Oz&#39; (1939), &#39;M&#39; (1931).&quot;</span>;
<span class="kw">for </span>caps <span class="kw">in </span>re.captures_iter(text) {
    <span class="macro">println!</span>(<span class="string">&quot;Movie: {:?}, Released: {:?}&quot;</span>,
             <span class="kw-2">&amp;</span>caps[<span class="string">&quot;title&quot;</span>], <span class="kw-2">&amp;</span>caps[<span class="string">&quot;year&quot;</span>]);
}
<span class="comment">// Output:
// Movie: Citizen Kane, Released: 1941
// Movie: The Wizard of Oz, Released: 1939
// Movie: M, Released: 1931</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>) -&gt; Split&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator of substrings of <code>text</code> delimited by a match of the
regular expression. Namely, each element of the iterator corresponds to
text that <em>isn’t</em> matched by the regular expression.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<p>To split a string delimited by arbitrary amounts of spaces or tabs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;[ \t]+&quot;</span>).unwrap();
<span class="kw">let </span>fields: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = re.split(<span class="string">&quot;a b \t  c\td    e&quot;</span>).collect();
<span class="macro">assert_eq!</span>(fields, <span class="macro">vec!</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>, limit: <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a>) -&gt; SplitN&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator of at most <code>limit</code> substrings of <code>text</code> delimited
by a match of the regular expression. (A <code>limit</code> of <code>0</code> will return no
substrings.) Namely, each element of the iterator corresponds to text
that <em>isn’t</em> matched by the regular expression. The remainder of the
string that is not split will be the last element in the iterator.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<p>Get the first two words in some text:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;\W+&quot;</span>).unwrap();
<span class="kw">let </span>fields: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = re.splitn(<span class="string">&quot;Hey! How are you?&quot;</span>, <span class="number">3</span>).collect();
<span class="macro">assert_eq!</span>(fields, <span class="macro">vec!</span>(<span class="string">&quot;Hey&quot;</span>, <span class="string">&quot;How&quot;</span>, <span class="string">&quot;are you?&quot;</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>&lt;R, 't&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>, rep: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: Replacer,</span></h4></section></summary><div class="docblock"><p>Replaces the leftmost-first match with the replacement provided.
The replacement can be a regular string (where <code>$N</code> and <code>$name</code> are
expanded to match capture groups) or a function that takes the matches’
<code>Captures</code> and returns the replaced string.</p>
<p>If no match is found, then a copy of the string is returned unchanged.</p>
<h5 id="replacement-string-syntax"><a href="#replacement-string-syntax">Replacement string syntax</a></h5>
<p>All instances of <code>$name</code> in the replacement text is replaced with the
corresponding capture group <code>name</code>.</p>
<p><code>name</code> may be an integer corresponding to the index of the
capture group (counted by order of opening parenthesis where <code>0</code> is the
entire match) or it can be a name (consisting of letters, digits or
underscores) corresponding to a named capture group.</p>
<p>If <code>name</code> isn’t a valid capture group (whether the name doesn’t exist
or isn’t a valid index), then it is replaced with the empty string.</p>
<p>The longest possible name is used. e.g., <code>$1a</code> looks up the capture
group named <code>1a</code> and not the capture group at index <code>1</code>. To exert more
precise control over the name, use braces, e.g., <code>${1}a</code>.</p>
<p>To write a literal <code>$</code> use <code>$$</code>.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>Note that this function is polymorphic with respect to the replacement.
In typical usage, this can just be a normal string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">&quot;[^01]+&quot;</span>).unwrap();
<span class="macro">assert_eq!</span>(re.replace(<span class="string">&quot;1078910&quot;</span>, <span class="string">&quot;&quot;</span>), <span class="string">&quot;1010&quot;</span>);</code></pre></div>
<p>But anything satisfying the <code>Replacer</code> trait will work. For example,
a closure of type <code>|&amp;Captures| -&gt; String</code> provides direct access to the
captures corresponding to a match. This allows one to access
capturing group matches easily:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;([^,\s]+),\s+(\S+)&quot;</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">&quot;Springsteen, Bruce&quot;</span>, |caps: <span class="kw-2">&amp;</span>Captures| {
    <span class="macro">format!</span>(<span class="string">&quot;{} {}&quot;</span>, <span class="kw-2">&amp;</span>caps[<span class="number">2</span>], <span class="kw-2">&amp;</span>caps[<span class="number">1</span>])
});
<span class="macro">assert_eq!</span>(result, <span class="string">&quot;Bruce Springsteen&quot;</span>);</code></pre></div>
<p>But this is a bit cumbersome to use all the time. Instead, a simple
syntax is supported that expands <code>$name</code> into the corresponding capture
group. Here’s the last example, but using this expansion technique
with named capture groups:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;(?P&lt;last&gt;[^,\s]+),\s+(?P&lt;first&gt;\S+)&quot;</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">&quot;Springsteen, Bruce&quot;</span>, <span class="string">&quot;$first $last&quot;</span>);
<span class="macro">assert_eq!</span>(result, <span class="string">&quot;Bruce Springsteen&quot;</span>);</code></pre></div>
<p>Note that using <code>$2</code> instead of <code>$first</code> or <code>$1</code> instead of <code>$last</code>
would produce the same result. To write a literal <code>$</code> use <code>$$</code>.</p>
<p>Sometimes the replacement string requires use of curly braces to
delineate a capture group replacement and surrounding literal text.
For example, if we wanted to join two words together with an
underscore:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r&quot;(?P&lt;first&gt;\w+)\s+(?P&lt;second&gt;\w+)&quot;</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">&quot;deep fried&quot;</span>, <span class="string">&quot;${first}_$second&quot;</span>);
<span class="macro">assert_eq!</span>(result, <span class="string">&quot;deep_fried&quot;</span>);</code></pre></div>
<p>Without the curly braces, the capture group name <code>first_</code> would be
used, and since it doesn’t exist, it would be replaced with the empty
string.</p>
<p>Finally, sometimes you just want to replace a literal string with no
regard for capturing group expansion. This can be done by wrapping a
byte string with <code>NoExpand</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::NoExpand;

<span class="kw">let </span>re = Regex::new(<span class="string">r&quot;(?P&lt;last&gt;[^,\s]+),\s+(\S+)&quot;</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">&quot;Springsteen, Bruce&quot;</span>, NoExpand(<span class="string">&quot;$2 $last&quot;</span>));
<span class="macro">assert_eq!</span>(result, <span class="string">&quot;$2 $last&quot;</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace_all" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.replace_all" class="fn">replace_all</a>&lt;R, 't&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>, rep: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: Replacer,</span></h4></section></summary><div class="docblock"><p>Replaces all non-overlapping matches in <code>text</code> with the replacement
provided. This is the same as calling <code>replacen</code> with <code>limit</code> set to
<code>0</code>.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement string.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replacen" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.replacen" class="fn">replacen</a>&lt;R, 't&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>, limit: <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a>, rep: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>&gt;<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: Replacer,</span></h4></section></summary><div class="docblock"><p>Replaces at most <code>limit</code> non-overlapping matches in <code>text</code> with the
replacement provided. If <code>limit</code> is 0, then all non-overlapping matches
are replaced.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement string.</p>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shortest_match" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.shortest_match" class="fn">shortest_match</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the end location of a match in the text given.</p>
<p>This method may have the same performance characteristics as
<code>is_match</code>, except it provides an end location for a match. In
particular, the location returned <em>may be shorter</em> than the proper end
of the leftmost-first match.</p>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<p>Typically, <code>a+</code> would match the entire first sequence of <code>a</code> in some
text, but <code>shortest_match</code> can give up as soon as it sees the first
<code>a</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;aaaaa&quot;</span>;
<span class="kw">let </span>pos = Regex::new(<span class="string">r&quot;a+&quot;</span>).unwrap().shortest_match(text);
<span class="macro">assert_eq!</span>(pos, <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shortest_match_at" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.shortest_match_at" class="fn">shortest_match_at</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the same as shortest_match, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_match_at" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.is_match_at" class="fn">is_match_at</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns the same as is_match, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.find_at" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.find_at" class="fn">find_at</a>&lt;'t&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the same as find, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_read" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.captures_read" class="fn">captures_read</a>&lt;'t&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;locs: &amp;mut CaptureLocations,<br>&nbsp;&nbsp;&nbsp;&nbsp;text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>This is like <code>captures</code>, but uses
<a href="struct.CaptureLocations.html"><code>CaptureLocations</code></a>
instead of
<a href="struct.Captures.html"><code>Captures</code></a> in order to amortize allocations.</p>
<p>To create a <code>CaptureLocations</code> value, use the
<code>Regex::capture_locations</code> method.</p>
<p>This returns the overall match if this was successful, which is always
equivalence to the <code>0</code>th capture group.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_read_at" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.captures_read_at" class="fn">captures_read_at</a>&lt;'t&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self,<br>&nbsp;&nbsp;&nbsp;&nbsp;locs: &amp;mut CaptureLocations,<br>&nbsp;&nbsp;&nbsp;&nbsp;text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;start: <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the same as captures, but starts the search at the given
offset and populates the capture locations given.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_str" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.as_str" class="fn">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns the original string of this regex.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.capture_names" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.capture_names" class="fn">capture_names</a>(&amp;self) -&gt; CaptureNames&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the capture names.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.captures_len" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.captures_len" class="fn">captures_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of captures.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.capture_locations" class="method has-srclink"><h4 class="code-header">pub fn <a href="#method.capture_locations" class="fn">capture_locations</a>(&amp;self) -&gt; CaptureLocations</h4></section></summary><div class="docblock"><p>Returns an empty set of capture locations that can be reused in
multiple calls to <code>captures_read</code> or <code>captures_read_at</code>.</p>
</div></details></div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Deref-for-RE_ID" class="impl has-srclink"><a class="srclink rightside" href="../../../src/diatom_cli/cli/highlighter.rs.html#30-48">source</a><a href="#impl-Deref-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.RE_ID.html" title="struct diatom_cli::cli::highlighter::RE_ID">RE_ID</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.67.1/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = Regex</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl has-srclink"><a class="srclink rightside" href="../../../src/diatom_cli/cli/highlighter.rs.html#30-48">source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.67.1/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;Regex</h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><section id="impl-LazyStatic-for-RE_ID" class="impl has-srclink"><a class="srclink rightside" href="../../../src/diatom_cli/cli/highlighter.rs.html#30-48">source</a><a href="#impl-LazyStatic-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://docs.rs/lazy_static/1.4.0/lazy_static/trait.LazyStatic.html" title="trait lazy_static::LazyStatic">LazyStatic</a> for <a class="struct" href="struct.RE_ID.html" title="struct diatom_cli::cli::highlighter::RE_ID">RE_ID</a></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-RE_ID" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.RE_ID.html" title="struct diatom_cli::cli::highlighter::RE_ID">RE_ID</a></h3></section><section id="impl-Send-for-RE_ID" class="impl has-srclink"><a href="#impl-Send-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.RE_ID.html" title="struct diatom_cli::cli::highlighter::RE_ID">RE_ID</a></h3></section><section id="impl-Sync-for-RE_ID" class="impl has-srclink"><a href="#impl-Sync-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.RE_ID.html" title="struct diatom_cli::cli::highlighter::RE_ID">RE_ID</a></h3></section><section id="impl-Unpin-for-RE_ID" class="impl has-srclink"><a href="#impl-Unpin-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.RE_ID.html" title="struct diatom_cli::cli::highlighter::RE_ID">RE_ID</a></h3></section><section id="impl-UnwindSafe-for-RE_ID" class="impl has-srclink"><a href="#impl-UnwindSafe-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.RE_ID.html" title="struct diatom_cli::cli::highlighter::RE_ID">RE_ID</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-RE_ID" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.67.1/src/core/any.rs.html#200">source</a><a href="#impl-Any-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.67.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.67.1/src/core/any.rs.html#201">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.67.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.67.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.67.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-RE_ID" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.67.1/src/core/borrow.rs.html#211">source</a><a href="#impl-Borrow%3CT%3E-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.67.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.67.1/src/core/borrow.rs.html#213">source</a></span><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-RE_ID" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.67.1/src/core/borrow.rs.html#220">source</a><a href="#impl-BorrowMut%3CT%3E-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.67.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.67.1/src/core/borrow.rs.html#221">source</a></span><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.67.1/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.67.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-RE_ID" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.67.1/src/core/convert/mod.rs.html#733">source</a><a href="#impl-From%3CT%3E-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.67.1/src/core/convert/mod.rs.html#736">source</a></span><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.67.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-RE_ID" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.67.1/src/core/convert/mod.rs.html#717">source</a><a href="#impl-Into%3CU%3E-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.67.1/src/core/convert/mod.rs.html#725">source</a></span><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.67.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.67.1/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-RE_ID" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.67.1/src/core/convert/mod.rs.html#775">source</a><a href="#impl-TryFrom%3CU%3E-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.67.1/src/core/convert/mod.rs.html#781">source</a></span><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-RE_ID" class="impl has-srclink"><a class="srclink rightside" href="https://doc.rust-lang.org/1.67.1/src/core/convert/mod.rs.html#760">source</a><a href="#impl-TryInto%3CU%3E-for-RE_ID" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.67.1/src/core/convert/mod.rs.html#766">source</a></span><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.67.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.67.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="diatom_cli" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.1 (d5a82bbd2 2023-02-07)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>